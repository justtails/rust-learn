# Rust Learn

Структурированная программа обучения Rust, сформулированная DeepSeek, которая фокусируется исключительно на языке и его концепциях, начиная с основ и заканчивая продвинутыми темами. Программа разделена на модули с ключевыми темами и практическими задачами.

## Программа обучения

### **Программа обучения языку Rust**
**Цель:** Освоить синтаксис, идиомы и уникальные возможности Rust (владение, заимствование, времени жизни) для написания безопасного и эффективного системного кода.

---

### **Модуль 1: Основы синтаксиса и управление потоком**
**Цель:** Понять базовый синтаксис и структуры управления.
*   **Темы:**
    1.  **Hello World:** Структура `main()`, макрос `println!`.
    2.  **Переменные и константы:** Ключевое слово `let`, мутабельность (`mut`), константы (`const`).
    3.  **Примитивные типы данных:** Целочисленные, числа с плавающей точкой, логический тип, символы (`char`).
    4.  **Составные типы данных:** Кортежи (`tuple`), массивы (`array`), срезы (`slice`).
    5.  **Управление потоком:**
        *   Условия: `if`, `if let`, `else if`, `match`.
        *   Циклы: `loop`, `while`, `for` (итерация по коллекциям и диапазонам).
    6.  **Функции:** Объявление, параметры, возвращаемые значения (явный `return` или выражение без `;`). Модули и область видимости (`pub`).

*   **Практические задачи:**
    *   Конвертер температур (Цельсий ↔ Фаренгейт).
    *   Генератор n-го числа последовательности Фибоначчи.
    *   Вывод текста рождественской песни "The Twelve Days of Christmas" с использованием циклов и массивов данных.

---

### **Модуль 2: Владение (Ownership) — Сердце Rust**
**Цель:** Полностью понять систему владения, которая обеспечивает безопасность памяти без сборщика мусора.
*   **Темы:**
    1.  **Правила владения:** Основные три правила.
    2.  **Перемещение (Move):** Семантика перемещения для типов, не реализующих `Copy` (например, `String`, `Vec`).
    3.  **Клонирование (Clone):** Явное создание глубоких копий.
    4.  **Типы-копии (Copy):** Семантика копирования для простых типов, хранящихся в стеке (`i32`, `bool` и т.д.).
    5.  **Владение и функции:** Передача владения в функцию и возврат из функции.

*   **Практические задачи:**
    *   Написать несколько небольших функций, которые передают `String` и `i32`, чтобы пронаблюдать разницу в поведении (`Move` vs `Copy`).
    *   Создать функцию, которая принимает вектор, выводит его элементы и возвращает владение обратно в `main`.

---

### **Модуль 3: Заимствование (Borrowing) и Ссылки**
**Цель:** Научиться работать с данными, не принимая владение, используя ссылки.
*   **Темы:**
    1.  **Неизменяемые ссылки (`&T`):** Чтение данных без их изменения. Правило: множество неизменяемых ссылок одновременно.
    2.  **Изменяемые ссылки (`&mut T`):** Изменение заимствованных данных. Правило: только одна изменяемая ссылка в области видимости и никаких неизменяемых одновременно.
    3.  **"Висячие" ссылки (Dangling References):** Что это и как компилятор Rust их предотвращает.
    4.  **Срезы (`&[T]`, `&str`):** Представление части коллекции или строки.

*   **Практические задачи:**
    *   Написать функцию, которая находит первое слово в строке и возвращает срез к нему.
    *   Реализовать функцию, которая принимает изменяемую ссылку на вектор целых чисел и увеличивает каждый элемент на 1.

---

### **Модуль 4: Времени жизни (Lifetimes)**
**Цель:** Понять аннотации времени жизни для явного описания связей между временами жизни ссылок.
*   **Темы:**
    1.  **Концепция времени жизни:** Область видимости, в которой ссылка действительна.
    2.  **Выведение времени жизни:** Как компилятор в большинстве случаев выводит их сам.
    3.  **Аннотации времени жизни (`'a`):** Синтаксис и необходимость их использования в структурах и функциях, возвращающих ссылки.
    4.  **Три правила элизии времени жизни.**
    5.  **Статическое время жизни (`'static`).**

*   **Практические задачи:**
    *   Написать функцию `longest`, которая принимает два строковых среза и возвращает срез наиболее длинной строки. Потребует явной аннотации времени жизни.
    *   Создать структуру `Excerpt`, которая хранит срез строки.

---

### **Модуль 5: Структуры (Structs), Перечисления (Enums) и Сопоставление (Matching)**
**Цель:** Моделировать данные с помощью структур и перечислений.
*   **Темы:**
    1.  **Структуры:** Определение, создание экземпляров, поля, методы (блок `impl`), ассоциированные функции (например, конструкторы).
    2.  **Синтаксис обновления структур (`..`).**
    3.  **Перечисления (Enums):** Определение вариантов, данные внутри вариантов (как `Option<T>` и `Result<T, E>`).
    4.  **Конструкция `match`:** Исчерпывающее сопоставление, привязка значений.
    5.  **Поток управления `if let`:** Для упрощенного сопоставления с одним образцом.

*   **Практические задачи:**
    *   Определить структуру `Rectangle` с методами `area` и `can_hold`.
    *   Реализовать простой калькулятор, использующий `enum` для операций и `match` для вычислений.
    *   Моделирование состояния веб-приложения (например, `enum State { Loading, Loaded(String), Error }`).

---

### **Модуль 6: Обработка ошибок**
**Цель:** Эффективно обрабатывать ошибки в Rust, используя `Result` и `Option`.
*   **Темы:**
    1.  **`panic!` макрос:** Неустранимые ошибки.
    2.  **Тип `Result<T, E>`:** Устранимая ошибка. Обработка через `match`, `unwrap`, `expect`, `?` оператор (распространение ошибок).
    3.  **Тип `Option<T>`:** Представление наличия или отсутствия значения. Методы `unwrap_or`, `map`, `and_then`.
    4.  **Создание пользовательских типов ошибок.**

*   **Практические задачи:**
    *   Написать функцию для чтения числа из файла (симулировать) и возвращать `Result<i32, ParseIntError>`.
    *   Реализовать цепочку вызовов функций, возвращающих `Result`, с использованием оператора `?`.

---

### **Модуль 7: Обобщенные типы (Generics) и типажи (Traits)**
**Цель:** Писать повторно используемый полиморфный код.
*   **Темы:**
    1.  **Обобщенные функции и структуры:** Синтаксис `<T>`.
    2.  **Типажи (Traits):** Определение поведения (аналоги интерфейсов). Блок `impl Trait for Type`.
    3.  **Наследование типажей.**
    4.  **Типажи как параметры:** `fn func(item: &impl Trait)` и форма `fn func<T: Trait>(item: &T)`.
    5.  **`where` оговорки** для улучшения читаемости.
    6.  **Возврат типов, реализующих типаж (`-> impl Trait`).**

*   **Практические задачи:**
    *   Создать обобщенную функцию `largest`, которая работает для любого типа, реализующего типажи `PartialOrd` и `Copy`.
    *   Определить типаж `Summarizable` для структур `NewsArticle` и `Tweet`.

---

### **Модуль 8: Стандартная библиотека (Stdlib) - Коллекции**
**Цель:** Работать с основными структурами данных.
*   **Темы:**
    1.  **`Vec<T>`:** Динамический массив, основные методы (`push`, `pop`, `iter`).
    2.  **`String` vs `&str`:** Мutable vs immutable строки, основные операции.
    3.  **`HashMap<K, V>`:** Ассоциативный массив, вставка, получение, обновление.
    4.  **Итераторы и адаптеры итераторов:** `iter()`, `into_iter()`, `iter_mut()`, `map`, `filter`, `collect()`.

*   **Практические задачи:**
    *   Подсчет частоты слов в тексте с использованием `HashMap`.
    *   Преобразование списка чисел в вектор, увеличение каждого числа и фильтрация четных с помощью цепочки итераторов.

---

### **Модуль 9: Тестирование**
**Цель:** Писать модульные и интеграционные тесты.
*   **Темы:**
    1.  **Модульные тесты:** Атрибут `#[test]`, макрос `assert!`, `assert_eq!`, `assert_ne!`.
    2.  **Организация тестов:** Модуль `tests` с `#[cfg(test)]`.
    3.  **Тестирование паник:** `#[should_panic]`.
    4.  **Интеграционные тесты:** Директория `tests/` на верхнем уровне.

*   **Практические задачи:**
    *   Написать модульные тесты для функции `add_two` и структуры `Rectangle` из предыдущих модулей.
    *   Создать простой интеграционный тест.

---

### **Модуль 10: Продвинутые темы (обзор и введение)**
**Цель:** Познакомиться с мощными возможностями Rust для углубленного изучения.
*   **Темы:**
    1.  **Умные указатели:** `Box<T>` (для рекурсивных структур), `Rc<T>` (подсчет ссылок), `RefCell<T>` (внутренняя изменяемость).
    2.  **Многопоточность (`Concurrency`):** `thread::spawn`, каналы (`mpsc`), разделяемое состояние с `Mutex<T>` и `Arc<T>`.
    3.  **Замыкания (Closures):** Синтаксис, захват переменных из окружения, типажи `Fn`, `FnMut`, `FnOnce`.
    4.  **Макросы (`macro_rules!`):** Объявление макросов и их использование.

*   **Практические задачи (опционально, более сложные):**
    *   Реализовать простой связанный список с помощью `Box`.
    *   Создать многопоточный сканер портов (учебный пример) или вычислитель с использованием пула потоков.
    *   Написать простой макрос для удобного логирования.

---

### **Финальный проект**
**Задача:** Объединить полученные знания в одном проекте.
**Примеры идей:**
*   **CLI утилита:** Аналог `grep` (поиск по файлам), простой калькулятор выражений.
*   **Мини-веб-сервер:** С использованием крейта `actix-web` или `rocket` (потребует изучения основ асинхронности и работы с крейтами).
*   **Эмулятор CHIP-8:** Отличный проект для понимания работы с памятью и битовыми операциями.
*   **Парсер Markdown или JSON:** Работа с текстом и рекурсивными структурами данных.

### **Рекомендуемые ресурсы (для изучения теории)**
*   **Официальная книга "The Rust Programming Language" ("Книга"):** [`doc.rust-lang.org/book/`](https://doc.rust-lang.org/book/)
*   **Rust by Example:** [`doc.rust-lang.org/rust-by-example/`](https://doc.rust-lang.org/rust-by-example/) (интерактивные примеры)
*   **Упражнения:** `rustlings` (маленькие интерактивные задания для отработки синтаксиса).

**Примечание:** Эта программа предполагает, что у вас уже настроена среда (компилятор `rustc`, менеджер пакетов `cargo` и, возможно, IDE/редактор). Весь код можно писать в файлах `.rs` и запускать через `cargo new`, `cargo build`, `cargo run`.